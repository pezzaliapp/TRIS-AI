<!doctype html>
<html lang="it">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>Tris AI¬≥ ‚Äî Surface Battle (4√ó4√ó4 WebGL2)</title>
  <style>
    :root{
      --bg:#070a10; --text:#e9eef7; --muted:#9fb0c8; --line: rgba(255,255,255,.12);
      --panel: rgba(18,26,39,.55); --shadow: 0 18px 55px rgba(0,0,0,.45); --radius: 18px;
    }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{
      margin:0; font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial;
      color: var(--text);
      background:
        radial-gradient(1100px 700px at 20% 10%, rgba(74,163,255,.18), transparent 55%),
        radial-gradient(900px 700px at 80% 25%, rgba(68,209,158,.14), transparent 55%),
        radial-gradient(1000px 800px at 60% 90%, rgba(255,255,255,.06), transparent 60%),
        var(--bg);
      overflow:hidden;
    }

    .app{
      min-height:100dvh;
      display:grid;
      grid-template-columns:1.25fr .75fr;
      gap:18px;
      padding:18px;
    }

    @media (max-width: 900px){
      body{
        overflow-y:auto;
        padding-bottom: env(safe-area-inset-bottom);
      }
      .app{
        grid-template-columns: 1fr !important;
        height: auto !important;
        padding: 14px !important;
        gap: 14px !important;
      }
      #viewport{
        height: 62svh !important;
        min-height: 420px !important;
      }
      .app > .panel:last-child{
        max-height: none !important;
        overflow: auto !important;
        -webkit-overflow-scrolling: touch;
      }
    }

    .panel{
      border:1px solid var(--line);
      border-radius:var(--radius);
      box-shadow:var(--shadow);
      overflow:hidden;
      background: linear-gradient(180deg, rgba(255,255,255,.06), rgba(255,255,255,.02));
      backdrop-filter: blur(10px);
    }

    /* pannello destro scrollabile (punteggio sempre raggiungibile) */
    .app > .panel:last-child{
      overflow:auto;
      -webkit-overflow-scrolling: touch;
    }
    .app > .panel:last-child .hdr{
      position:sticky;
      top:0;
      z-index:20;
    }

    .hdr{
      padding:18px 18px 12px; border-bottom:1px solid var(--line); background:var(--panel);
      display:flex; align-items:flex-start; justify-content:space-between; gap:12px;
    }
    h1{margin:0;font-size:18px;letter-spacing:.2px}
    .sub{color:var(--muted);font-size:13px;margin-top:4px;line-height:1.35}
    .badge{font-size:12px;color:var(--muted);border:1px solid var(--line);padding:6px 10px;border-radius:999px;background:rgba(0,0,0,.18);white-space:nowrap;}
    .content{padding:18px}
    .status{
      display:flex;align-items:flex-start;justify-content:space-between;gap:12px;
      padding:12px 14px;border:1px solid var(--line);border-radius:14px;background:rgba(0,0,0,.18);margin-bottom:14px;
    }
    .status .mini{color:var(--muted);font-size:12px}
    .pill{font-size:12px;padding:6px 10px;border-radius:999px;border:1px solid var(--line);color:var(--muted);background:rgba(255,255,255,.03);user-select:none;align-self:flex-start;}
    .controls{display:grid;grid-template-columns:1fr 1fr;gap:10px;margin-top:14px;}
    .btn{border:1px solid var(--line);background:rgba(255,255,255,.04);color:var(--text);padding:11px 12px;border-radius:14px;cursor:pointer;font-weight:950;}
    .btn.primary{border-color: rgba(74,163,255,.35); background: rgba(74,163,255,.14)}
    .btn.danger{border-color: rgba(255,74,106,.35); background: rgba(255,74,106,.10)}

    #viewport{
      width:100%;
      flex:1;
      min-height:520px;
      position:relative;
      overflow:hidden;
      border-top:1px solid rgba(255,255,255,.06);
      background: radial-gradient(700px 500px at 40% 15%, rgba(255,255,255,.05), transparent 60%);
      touch-action:none; /* IMPORTANT: pointer gestures senza scroll */
    }
    canvas{display:block;width:100%;height:100%}
    .hud{
      position:absolute; left:12px; bottom:12px; z-index:6; pointer-events:none;
      background: rgba(0,0,0,.28); border:1px solid rgba(255,255,255,.10);
      color: rgba(255,255,255,.88); padding:10px 12px; border-radius:14px; font-size:12px; backdrop-filter: blur(8px);
    }

    .section{padding:16px 18px;border-top:1px solid var(--line)}
    .section h2{margin:0 0 10px;font-size:14px;letter-spacing:.2px;color:var(--muted);font-weight:950;text-transform:uppercase;}
    .row{
      display:flex;align-items:center;justify-content:space-between;gap:12px;
      padding:10px 12px;border-radius:14px;border:1px solid var(--line);background:rgba(0,0,0,.16);margin-bottom:10px;
    }
    label{font-size:13px;font-weight:950}
    input[type="range"]{width:200px}
    .toggle{display:flex;align-items:center;gap:10px;user-select:none;}
    .switch{width:46px;height:26px;border-radius:999px;border:1px solid var(--line);background:rgba(255,255,255,.04);position:relative;cursor:pointer;flex:0 0 auto;}
    .knob{width:20px;height:20px;border-radius:999px;background:rgba(255,255,255,.75);position:absolute;top:2px;left:2px;transition:left .18s ease, background .18s ease;}
    .switch.on{border-color: rgba(74,163,255,.35); background: rgba(74,163,255,.14);}
    .switch.on .knob{left:24px;background: rgba(255,255,255,.92);}
    .score{display:grid;grid-template-columns:1fr 1fr;gap:10px;}
    .card{border:1px solid var(--line);border-radius:16px;background:rgba(0,0,0,.16);padding:12px;}
    .k{font-size:12px;color:var(--muted);font-weight:950;letter-spacing:.3px;text-transform:uppercase;margin-bottom:6px}
    .v{font-size:22px;font-weight:950}
    .hint{font-size:13px;color:var(--muted);line-height:1.5;margin:0}

    .errorbox{position:absolute; inset:0; display:none; place-items:center; z-index:50; background: rgba(0,0,0,.55); backdrop-filter: blur(8px); padding:18px;}
    .errorcard{width:min(720px,100%); border:1px solid rgba(255,255,255,.14); border-radius:18px; background: rgba(10,14,22,.72); padding:16px; box-shadow: var(--shadow);}
    .errorcard pre{white-space:pre-wrap;color: rgba(255,255,255,.85);background: rgba(0,0,0,.25);border:1px solid rgba(255,255,255,.10);border-radius:14px;padding:12px;margin:10px 0 0;font-size:12px;line-height:1.4;}
  </style>
</head>
<body>
  <div class="app">

    <!-- LEFT -->
    <div class="panel" style="display:flex; flex-direction:column;">
      <div class="hdr">
        <div>
          <h1>Tris AI¬≥ ‚Äî Surface Battle (4√ó4√ó4)</h1>
          <div class="sub">Si gioca <b>solo sui cubetti di superficie</b> (tutte le facce). Ogni 4-in-linea valido = <b>+1 punto</b>.</div>
        </div>
        <div class="badge" id="linesBadge">Linee: ‚Ä¶</div>
      </div>

      <div class="content" style="padding-bottom:12px;">
        <div class="status" aria-live="polite">
          <div>
            <div class="mini">Stato</div>
            <div id="statusText"><strong>Tocca a X.</strong></div>
            <div class="mini" id="lineInfo" style="margin-top:4px; display:none;"></div>
          </div>
          <div class="pill" id="turnPill">Turno: X</div>
        </div>

        <div class="controls">
          <button class="btn primary" id="resetBtn">Nuova partita</button>
          <button class="btn danger" id="resetScoreBtn">Azzera punteggio</button>
        </div>
      </div>

      <div id="viewport">
        <canvas id="gl"></canvas>
        <div class="hud">Drag = ruota ‚Ä¢ Pinch/Scroll = zoom ‚Ä¢ Tap/Click = piazza ‚Ä¢ (solo superficie)</div>

        <div class="errorbox" id="errorbox">
          <div class="errorcard">
            <h3 style="margin:0 0 6px">WebGL non avviato</h3>
            <div class="hint">Safari/Chrome aggiornato. Se bloccato, prova a riaprire la pagina.</div>
            <pre id="errortext"></pre>
          </div>
        </div>
      </div>
    </div>

    <!-- RIGHT -->
    <div class="panel">
      <div class="hdr">
        <div>
          <h1>Controlli</h1>
          <div class="sub">Vista + didattica.</div>
        </div>
        <div class="badge">REAL 3D</div>
      </div>

      <div class="section">
        <h2>Vista</h2>
        <div class="row">
          <label for="zDepth">Profondit√† Z</label>
          <input id="zDepth" type="range" min="0.7" max="2.2" step="0.01" value="1.0" />
        </div>

        <div class="row">
          <div class="toggle">
            <div class="switch" id="explodeSwitch" role="switch" aria-checked="false" tabindex="0"><div class="knob"></div></div>
            <div>
              <div style="font-weight:950;font-size:13px">Esplodi livelli</div>
              <p class="hint">Aumenta spacing tra strati Z</p>
            </div>
          </div>
          <div class="badge" id="explodeBadge">OFF</div>
        </div>
      </div>

      <div class="section">
        <h2>Didattica</h2>
        <div class="row">
          <div class="toggle">
            <div class="switch on" id="teachSwitch" role="switch" aria-checked="true" tabindex="0"><div class="knob"></div></div>
            <div>
              <div style="font-weight:950;font-size:13px">Preview linee</div>
              <p class="hint">Hover (desktop) / tap (mobile): mostra linee possibili</p>
            </div>
          </div>
          <div class="badge" id="teachBadge">ON</div>
        </div>
      </div>

      <div class="section">
        <h2>Punteggio</h2>
        <div class="score">
          <div class="card"><div class="k">X</div><div class="v" id="scoreX">0</div></div>
          <div class="card"><div class="k">O</div><div class="v" id="scoreO">0</div></div>
        </div>
        <div style="margin-top:10px">
          <p class="hint">Le linee contate restano ‚Äúconsumate‚Äù: non valgono due volte. Vince chi fa pi√π punti quando finiscono le mosse sulla superficie.</p>
        </div>
      </div>
    </div>
  </div>

<script>
(() => {
  const clamp = (v,a,b)=>Math.max(a,Math.min(b,v));

  function showError(msg){
    const e = document.getElementById('errortext');
    if(e) e.textContent = msg;
    const box = document.getElementById('errorbox');
    if(box) box.style.display = 'grid';
  }

  // DOM
  const linesBadge    = document.getElementById('linesBadge');
  const statusText    = document.getElementById('statusText');
  const turnPill      = document.getElementById('turnPill');
  const lineInfo      = document.getElementById('lineInfo');
  const resetBtn      = document.getElementById('resetBtn');
  const resetScoreBtn = document.getElementById('resetScoreBtn');
  const zDepth        = document.getElementById('zDepth');
  const explodeSwitch = document.getElementById('explodeSwitch');
  const explodeBadge  = document.getElementById('explodeBadge');
  const teachSwitch   = document.getElementById('teachSwitch');
  const teachBadge    = document.getElementById('teachBadge');
  const scoreXEl      = document.getElementById('scoreX');
  const scoreOEl      = document.getElementById('scoreO');

  function setStatus(msg){ statusText.innerHTML = `<strong>${msg}</strong>`; }
  function updateTurn(){ turnPill.textContent = `Turno: ${current}`; }
  function updateScores(){ scoreXEl.textContent=score.X; scoreOEl.textContent=score.O; }

  function toggleSwitch(el, forced){
    if(forced===undefined) el.classList.toggle('on');
    else el.classList.toggle('on', !!forced);
    el.setAttribute('aria-checked', el.classList.contains('on')?'true':'false');
    return el.classList.contains('on');
  }

  // Mat4 minimal (column-major)
  const mat4={
    I:()=>{const m=new Float32Array(16);m[0]=m[5]=m[10]=m[15]=1;return m;},
    mul:(a,b)=>{const o=new Float32Array(16);
      for(let c=0;c<4;c++)for(let r=0;r<4;r++){
        o[c*4+r]=a[0*4+r]*b[c*4+0]+a[1*4+r]*b[c*4+1]+a[2*4+r]*b[c*4+2]+a[3*4+r]*b[c*4+3];
      }return o;},
    rotX:(A)=>{const m=mat4.I(),c=Math.cos(A),s=Math.sin(A);m[5]=c;m[9]=-s;m[6]=s;m[10]=c;return m;},
    rotY:(A)=>{const m=mat4.I(),c=Math.cos(A),s=Math.sin(A);m[0]=c;m[8]=s;m[2]=-s;m[10]=c;return m;},
    persp:(fovy,asp,n,f)=>{const t=1/Math.tan(fovy/2),m=new Float32Array(16);
      m[0]=t/asp;m[5]=t;m[10]=(f+n)/(n-f);m[11]=-1;m[14]=(2*f*n)/(n-f);return m;},
    lookAt:(e,t,u)=>{
      let zx=e[0]-t[0], zy=e[1]-t[1], zz=e[2]-t[2];
      const zL=Math.hypot(zx,zy,zz)||1; zx/=zL; zy/=zL; zz/=zL;
      let xx=u[1]*zz-u[2]*zy, xy=u[2]*zx-u[0]*zz, xz=u[0]*zy-u[1]*zx;
      const xL=Math.hypot(xx,xy,xz)||1; xx/=xL; xy/=xL; xz/=xL;
      const yx=zy*xz-zz*xy, yy=zz*xx-zx*xz, yz=zx*xy-zy*xx;
      const m=mat4.I();
      m[0]=xx;m[4]=xy;m[8]=xz;
      m[1]=yx;m[5]=yy;m[9]=yz;
      m[2]=zx;m[6]=zy;m[10]=zz;
      m[12]=-(xx*e[0]+xy*e[1]+xz*e[2]);
      m[13]=-(yx*e[0]+yy*e[1]+yz*e[2]);
      m[14]=-(zx*e[0]+zy*e[1]+zz*e[2]);
      return m;
    }
  };

  // GAME (surface battle)
  const N=4, SIZE=N*N*N;
  const idx=(x,y,z)=>z*N*N + y*N + x;
  const toXYZ=(i)=>{
    const z=Math.floor(i/(N*N));
    const r=i%(N*N);
    const y=Math.floor(r/N);
    const x=r%N;
    return {x,y,z};
  };
  const inBounds=(x,y,z)=>x>=0&&x<N&&y>=0&&y<N&&z>=0&&z<N;

  function isSurfaceIndex(i){
  const p=toXYZ(i);
  return (p.x===0||p.x===N-1||p.y===0||p.y===N-1||p.z===0||p.z===N-1);
}

// Colori facce (blend su spigoli/vertici)
function surfaceTint(i){
  const p = toXYZ(i);

  // base freddo scuro
  let r = 0.10, g = 0.13, b = 0.18;

  // contributi per faccia (leggeri ma visibili)
  // x=0 (sinistra)   -> blu
  if(p.x===0) { r+=0.05; g+=0.12; b+=0.32; }

  // x=3 (destra)     -> verde
  if(p.x===N-1) { r+=0.06; g+=0.28; b+=0.10; }

  // y=0 (alto)       -> viola
  if(p.y===0) { r+=0.22; g+=0.08; b+=0.30; }

  // y=3 (basso)      -> ambra
  if(p.y===N-1) { r+=0.28; g+=0.18; b+=0.05; }

  // z=0 (front)      -> ciano
  if(p.z===0) { r+=0.05; g+=0.28; b+=0.26; }

  // z=3 (back)       -> rosso tenue
  if(p.z===N-1) { r+=0.30; g+=0.08; b+=0.08; }

  // clamp
  r = Math.min(1, r);
  g = Math.min(1, g);
  b = Math.min(1, b);

  return [r,g,b];
}

  function generateLines(n){
    const dirs=[];
    for(let dx=-1;dx<=1;dx++)
      for(let dy=-1;dy<=1;dy++)
        for(let dz=-1;dz<=1;dz++){
          if(dx===0&&dy===0&&dz===0) continue;
          const firstNonZero=(dx!==0)?dx:(dy!==0?dy:dz);
          if(firstNonZero<0) continue;
          dirs.push([dx,dy,dz]);
        }
    const set=new Set(), lines=[];
    for(let z=0;z<n;z++) for(let y=0;y<n;y++) for(let x=0;x<n;x++){
      for(const [dx,dy,dz] of dirs){
        const coords=[];
        let ok=true;
        for(let k=0;k<n;k++){
          const xx=x+dx*k, yy=y+dy*k, zz=z+dz*k;
          if(!inBounds(xx,yy,zz)){ok=false;break;}
          coords.push(idx(xx,yy,zz));
        }
        if(!ok) continue;
        if(inBounds(x-dx,y-dy,z-dz)) continue;
        const key=coords.join(',');
        if(!set.has(key)){set.add(key);lines.push(coords);}
      }
    }
    return lines;
  }

  // SOLO linee ‚Äúgiocabili‚Äù: tutte le celle della linea devono stare in superficie
  const ALL_LINES = generateLines(N);
  const WIN_LINES = ALL_LINES.filter(line => line.every(isSurfaceIndex));
  linesBadge.textContent = `Linee (surface): ${WIN_LINES.length}`;

  const LINES_THROUGH = Array.from({length:SIZE},()=>[]);
  for(const line of WIN_LINES) for(const c of line) LINES_THROUGH[c].push(line);

  let board=Array(SIZE).fill(null);
  let current='X';
  let gameOver=false;

  let teach=true;
  let explode=false;
  let zScale=1.0;

  let score={X:0,O:0};

  let hoveredIndex=null;
  let previewLines=[];
  let lastScoredLinesText='';

  // set di linee gi√† contate (per non contare due volte)
  const scoredLines = new Set();

  // WebGL2
  const canvas = document.getElementById('gl');
  const gl = canvas.getContext('webgl2', {antialias:true, alpha:true, depth:true});
  if(!gl){
    showError('Impossibile creare WebGL2. Prova Safari/Chrome aggiornato o abilita WebGL.');
    return;
  }

  function compile(type, src){
    const s=gl.createShader(type);
    gl.shaderSource(s,src);
    gl.compileShader(s);
    if(!gl.getShaderParameter(s, gl.COMPILE_STATUS)){
      const info=gl.getShaderInfoLog(s);
      gl.deleteShader(s);
      throw new Error(info);
    }
    return s;
  }
  function link(vs,fs){
    const p=gl.createProgram();
    gl.attachShader(p,vs); gl.attachShader(p,fs);
    gl.linkProgram(p);
    if(!gl.getProgramParameter(p, gl.LINK_STATUS)){
      const info=gl.getProgramInfoLog(p);
      gl.deleteProgram(p);
      throw new Error(info);
    }
    return p;
  }

  // Shaders
  const vsLit=`#version 300 es
  precision highp float;

  layout(location=0) in vec3 aPos;
  layout(location=1) in vec3 aNor;

  layout(location=2) in vec3  iT;
  layout(location=3) in vec4  iCol;
  layout(location=4) in float iVis;
  layout(location=6) in float iS;

  uniform mat4 uVP;
  uniform mat4 uW;

  out vec3 vN;
  out vec3 vP;
  out vec4 vC;
  out float vV;

  void main(){
    vV = iVis;
    vec3 pLocal = aPos * iS;
    vec4 p = uW * vec4(pLocal + iT, 1.0);
    gl_Position = uVP * p;

    vP = p.xyz;
    vN = mat3(uW) * aNor;
    vC = iCol;
  }`;

  const fsLit=`#version 300 es
  precision highp float;

  in vec3 vN;
  in vec3 vP;
  in vec4 vC;
  in float vV;

  out vec4 o;

  void main(){
    if(vV < 0.5) discard;

    vec3 n = normalize(vN);
    vec3 l = normalize(vec3(0.55, 1.0, 0.75));
    float d = max(dot(n, l), 0.0);

    vec3 v = normalize(-vP);
    float rim = pow(1.0 - max(dot(n, v), 0.0), 2.2);

    vec3 col = vC.rgb * (0.34 + 0.76 * d) + vec3(0.22) * rim;
    o = vec4(col, vC.a);
  }`;

  const vsPick=`#version 300 es
  precision highp float;
  layout(location=0) in vec3 aPos;
  layout(location=2) in vec3 iT;
  layout(location=4) in float iVis;
  layout(location=5) in vec3 iPick;
  uniform mat4 uVP;
  uniform mat4 uW;
  out vec3 vPick; out float vV;
  void main(){
    vV=iVis; vPick=iPick;
    gl_Position=uVP*(uW*vec4(aPos+iT,1.0));
  }`;

  const fsPick=`#version 300 es
  precision highp float;
  in vec3 vPick; in float vV;
  out vec4 o;
  void main(){ if(vV<0.5) discard; o=vec4(vPick,1.0); }`;

  const vsLine=`#version 300 es
  precision highp float;
  layout(location=0) in vec3 aPos;
  uniform mat4 uVP;
  void main(){ gl_Position=uVP*vec4(aPos,1.0); }`;

  const fsLine=`#version 300 es
  precision highp float;
  uniform vec4 uCol;
  out vec4 o;
  void main(){ o=uCol; }`;

  let PLIT, PPICK, PLINE;
  try{
    PLIT = link(compile(gl.VERTEX_SHADER,vsLit), compile(gl.FRAGMENT_SHADER,fsLit));
    PPICK = link(compile(gl.VERTEX_SHADER,vsPick), compile(gl.FRAGMENT_SHADER,fsPick));
    PLINE = link(compile(gl.VERTEX_SHADER,vsLine), compile(gl.FRAGMENT_SHADER,fsLine));
  }catch(e){
    showError('Shader error:\n'+(e.message||String(e)));
    return;
  }

  // Geometry
  function mergeMeshes(meshes){
    let totalV=0, totalI=0;
    for(const m of meshes){ totalV += m.pos.length/3; totalI += m.idx.length; }
    const pos=new Float32Array(totalV*3);
    const nor=new Float32Array(totalV*3);
    const idx=new Uint32Array(totalI);
    let vOff=0, iOff=0;
    for(const m of meshes){
      pos.set(m.pos, vOff*3);
      nor.set(m.nor, vOff*3);
      for(let k=0;k<m.idx.length;k++) idx[iOff+k] = m.idx[k] + vOff;
      vOff += m.pos.length/3;
      iOff += m.idx.length;
    }
    return {pos,nor,idx};
  }

  function makeCube(){
    const p=[], n=[], idxs=[];
    const faces=[
      {nor:[ 1,0,0],v:[[ .5,-.5,-.5],[ .5,.5,-.5],[ .5,.5,.5],[ .5,-.5,.5]]},
      {nor:[-1,0,0],v:[[-.5,-.5,.5],[-.5,.5,.5],[-.5,.5,-.5],[-.5,-.5,-.5]]},
      {nor:[0, 1,0],v:[[-.5,.5,-.5],[-.5,.5,.5],[ .5,.5,.5],[ .5,.5,-.5]]},
      {nor:[0,-1,0],v:[[-.5,-.5,.5],[-.5,-.5,-.5],[ .5,-.5,-.5],[ .5,-.5,.5]]},
      {nor:[0,0, 1],v:[[-.5,-.5,.5],[ .5,-.5,.5],[ .5,.5,.5],[-.5,.5,.5]]},
      {nor:[0,0,-1],v:[[ .5,-.5,-.5],[-.5,-.5,-.5],[-.5,.5,-.5],[ .5,.5,-.5]]},
    ];
    let vi=0;
    for(const f of faces){
      p.push(...f.v[0],...f.v[1],...f.v[2],...f.v[3]);
      for(let k=0;k<4;k++) n.push(...f.nor);
      idxs.push(vi,vi+1,vi+2, vi,vi+2,vi+3);
      vi+=4;
    }
    return {pos:new Float32Array(p), nor:new Float32Array(n), idx:new Uint16Array(idxs)};
  }

  function makeBox(w,h,d){
    const x=w/2,y=h/2,z=d/2;
    const faces=[
      {nor:[ 1,0,0], v:[[ x,-y,-z],[ x, y,-z],[ x, y, z],[ x,-y, z]]},
      {nor:[-1,0,0], v:[[-x,-y, z],[-x, y, z],[-x, y,-z],[-x,-y,-z]]},
      {nor:[0, 1,0], v:[[-x, y,-z],[-x, y, z],[ x, y, z],[ x, y,-z]]},
      {nor:[0,-1,0], v:[[-x,-y, z],[-x,-y,-z],[ x,-y,-z],[ x,-y, z]]},
      {nor:[0,0, 1], v:[[-x,-y, z],[ x,-y, z],[ x, y, z],[-x, y, z]]},
      {nor:[0,0,-1], v:[[ x,-y,-z],[-x,-y,-z],[-x, y,-z],[ x, y,-z]]},
    ];
    const p=[], n=[], idx=[];
    let vi=0;
    for(const f of faces){
      p.push(...f.v[0],...f.v[1],...f.v[2],...f.v[3]);
      for(let k=0;k<4;k++) n.push(...f.nor);
      idx.push(vi,vi+1,vi+2, vi,vi+2,vi+3);
      vi+=4;
    }
    return {pos:new Float32Array(p), nor:new Float32Array(n), idx:new Uint16Array(idx)};
  }

  function rotateZ(mesh, a){
    const c=Math.cos(a), s=Math.sin(a);
    const pos=new Float32Array(mesh.pos.length);
    const nor=new Float32Array(mesh.nor.length);
    for(let i=0;i<mesh.pos.length;i+=3){
      const x=mesh.pos[i], y=mesh.pos[i+1], z=mesh.pos[i+2];
      pos[i]=c*x - s*y; pos[i+1]=s*x + c*y; pos[i+2]=z;
      const nx=mesh.nor[i], ny=mesh.nor[i+1], nz=mesh.nor[i+2];
      nor[i]=c*nx - s*ny; nor[i+1]=s*nx + c*ny; nor[i+2]=nz;
    }
    return {pos,nor,idx:mesh.idx};
  }

  function makeXMesh(){
    const bar = makeBox(0.85, 0.16, 0.10);
    const a = Math.PI/4;
    const b1 = rotateZ(bar, a);
    const b2 = rotateZ(bar, -a);
    return mergeMeshes([b1,b2]);
  }

  function makeTorus(R=0.33, r=0.095, segU=40, segV=20){
    const pos=[], nor=[], idx=[];
    for(let i=0;i<=segU;i++){
      const u=i/segU * Math.PI*2;
      const cu=Math.cos(u), su=Math.sin(u);
      for(let j=0;j<=segV;j++){
        const v=j/segV * Math.PI*2;
        const cv=Math.cos(v), sv=Math.sin(v);
        const x=(R + r*cv)*cu;
        const y=(R + r*cv)*su;
        const z=r*sv;
        const nx=cv*cu, ny=cv*su, nz=sv;
        pos.push(x,y,z);
        nor.push(nx,ny,nz);
      }
    }
    const row=segV+1;
    for(let i=0;i<segU;i++){
      for(let j=0;j<segV;j++){
        const a=i*row+j;
        const b=a+row;
        idx.push(a,b,a+1, b,b+1,a+1);
      }
    }
    return {pos:new Float32Array(pos), nor:new Float32Array(nor), idx:new Uint32Array(idx)};
  }

  const GEO_CUBE = makeCube();
  const GEO_X    = makeXMesh();
  const GEO_O    = makeTorus(0.33, 0.095, 40, 20);

  function makeVAO(geo, indexType){
    const vao=gl.createVertexArray();
    gl.bindVertexArray(vao);

    const vboP=gl.createBuffer(); gl.bindBuffer(gl.ARRAY_BUFFER,vboP);
    gl.bufferData(gl.ARRAY_BUFFER, geo.pos, gl.STATIC_DRAW);
    gl.enableVertexAttribArray(0); gl.vertexAttribPointer(0,3,gl.FLOAT,false,0,0);

    const vboN=gl.createBuffer(); gl.bindBuffer(gl.ARRAY_BUFFER,vboN);
    gl.bufferData(gl.ARRAY_BUFFER, geo.nor, gl.STATIC_DRAW);
    gl.enableVertexAttribArray(1); gl.vertexAttribPointer(1,3,gl.FLOAT,false,0,0);

    const ibo=gl.createBuffer(); gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER,ibo);
    gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, geo.idx, gl.STATIC_DRAW);

    gl.bindVertexArray(null);
    return {vao, count: geo.idx.length, indexType};
  }

  const VAO_CUBE = makeVAO(GEO_CUBE, gl.UNSIGNED_SHORT);
  const VAO_X    = makeVAO(GEO_X,    gl.UNSIGNED_INT);
  const VAO_O    = makeVAO(GEO_O,    gl.UNSIGNED_INT);

  // Instancing buffers
  function attachInstBuffers(vaoObj, instT, instCol, instVis){
    gl.bindVertexArray(vaoObj.vao);

    const bIT = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, bIT);
    gl.bufferData(gl.ARRAY_BUFFER, instT.byteLength, gl.DYNAMIC_DRAW);
    gl.enableVertexAttribArray(2);
    gl.vertexAttribPointer(2, 3, gl.FLOAT, false, 0, 0);
    gl.vertexAttribDivisor(2, 1);

    const bIC = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, bIC);
    gl.bufferData(gl.ARRAY_BUFFER, instCol.byteLength, gl.DYNAMIC_DRAW);
    gl.enableVertexAttribArray(3);
    gl.vertexAttribPointer(3, 4, gl.FLOAT, false, 0, 0);
    gl.vertexAttribDivisor(3, 1);

    const bIV = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, bIV);
    gl.bufferData(gl.ARRAY_BUFFER, instVis.byteLength, gl.DYNAMIC_DRAW);
    gl.enableVertexAttribArray(4);
    gl.vertexAttribPointer(4, 1, gl.FLOAT, false, 0, 0);
    gl.vertexAttribDivisor(4, 1);

    gl.bindVertexArray(null);
    return { bIT, bIC, bIV };
  }

  function attachInstScale(vaoObj, instScale){
    gl.bindVertexArray(vaoObj.vao);

    const bIS = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, bIS);
    gl.bufferData(gl.ARRAY_BUFFER, instScale.byteLength, gl.DYNAMIC_DRAW);

    gl.enableVertexAttribArray(6);
    gl.vertexAttribPointer(6, 1, gl.FLOAT, false, 0, 0);
    gl.vertexAttribDivisor(6, 1);

    gl.bindVertexArray(null);
    return bIS;
  }

  const INST = SIZE;

  // cubes
  const cubeT    = new Float32Array(INST * 3);
  const cubeC    = new Float32Array(INST * 4);
  const cubeV    = new Float32Array(INST);
  const cubePick = new Float32Array(INST * 3);
  const cubeS    = new Float32Array(INST);

  // X
  const xT = new Float32Array(INST * 3);
  const xC = new Float32Array(INST * 4);
  const xV = new Float32Array(INST);
  const xS = new Float32Array(INST);

  // O
  const oT = new Float32Array(INST * 3);
  const oC = new Float32Array(INST * 4);
  const oV = new Float32Array(INST);
  const oS = new Float32Array(INST);

  for(let i=0;i<INST;i++){
    cubeS[i]=1.0;
    xS[i]=0.0;
    oS[i]=0.0;
  }

  const BUF_CUBE = attachInstBuffers(VAO_CUBE, cubeT, cubeC, cubeV);
  const BUF_X    = attachInstBuffers(VAO_X,    xT,    xC,    xV);
  const BUF_O    = attachInstBuffers(VAO_O,    oT,    oC,    oV);

  const bCS = attachInstScale(VAO_CUBE, cubeS);
  const bXS = attachInstScale(VAO_X,    xS);
  const bOS = attachInstScale(VAO_O,    oS);

  // picking attribute (loc 5) solo su cubi
  gl.bindVertexArray(VAO_CUBE.vao);
  const bPick = gl.createBuffer();
  gl.bindBuffer(gl.ARRAY_BUFFER, bPick);
  gl.bufferData(gl.ARRAY_BUFFER, cubePick.byteLength, gl.DYNAMIC_DRAW);
  gl.enableVertexAttribArray(5);
  gl.vertexAttribPointer(5, 3, gl.FLOAT, false, 0, 0);
  gl.vertexAttribDivisor(5, 1);
  gl.bindVertexArray(null);

  // linee (preview)
  const vaoL = gl.createVertexArray();
  gl.bindVertexArray(vaoL);
  const vboL = gl.createBuffer();
  gl.bindBuffer(gl.ARRAY_BUFFER, vboL);
  gl.bufferData(gl.ARRAY_BUFFER, 4096, gl.DYNAMIC_DRAW);
  gl.enableVertexAttribArray(0);
  gl.vertexAttribPointer(0, 3, gl.FLOAT, false, 0, 0);
  gl.bindVertexArray(null);

  // picking FBO
  let pickFbo=null, pickTex=null, pickDepth=null, pickW=0, pickH=0;
  function ensurePickFbo(w,h){
    if(pickTex && pickW===w && pickH===h) return;
    pickW=w; pickH=h;

    if(pickFbo){
      gl.deleteFramebuffer(pickFbo);
      gl.deleteTexture(pickTex);
      gl.deleteRenderbuffer(pickDepth);
    }

    pickFbo = gl.createFramebuffer();
    gl.bindFramebuffer(gl.FRAMEBUFFER, pickFbo);

    pickTex = gl.createTexture();
    gl.bindTexture(gl.TEXTURE_2D, pickTex);
    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA8, w, h, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
    gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, pickTex, 0);

    pickDepth = gl.createRenderbuffer();
    gl.bindRenderbuffer(gl.RENDERBUFFER, pickDepth);
    gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_COMPONENT16, w, h);
    gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.RENDERBUFFER, pickDepth);

    const st = gl.checkFramebufferStatus(gl.FRAMEBUFFER);
    gl.bindFramebuffer(gl.FRAMEBUFFER, null);
    if(st !== gl.FRAMEBUFFER_COMPLETE){
      showError('Picking FBO non completo: ' + st);
    }
  }

  // CAMERA / GRID
  let theta = -0.7, phi = 0.95, radius = 10.8;
  let pan = [0, -0.55, 0];

  const IS_MOBILE = matchMedia('(max-width: 900px)').matches;
  if (IS_MOBILE) {
    radius = 14.2;
    phi = 1.05;
    theta = -0.62;
  }

  let __lastFitW = 0, __lastFitH = 0;
  function fitCameraToView(W, H){
    if(!IS_MOBILE) return;
    if(Math.abs(W-__lastFitW) < 40 && Math.abs(H-__lastFitH) < 40) return;
    __lastFitW = W; __lastFitH = H;
    const aspect = W / Math.max(1, H);
    const base = 14.2;
    radius = base + (aspect > 0.65 ? 0.0 : 2.2);
    radius = clamp(radius, 12.5, 18.5);
  }

  function getEye(){
    const x=radius*Math.cos(theta)*Math.sin(phi);
    const y=radius*Math.cos(phi);
    const z=radius*Math.sin(theta)*Math.sin(phi);
    return [x+pan[0], y+pan[1], z+pan[2]];
  }
  function getWorld(){
    const rx=mat4.rotX(0.08), ry=mat4.rotY(-0.12);
    return mat4.mul(ry,rx);
  }

  const cellSize=1.0, gap=0.22, spacingXY=cellSize+gap;
  const half=(N-1)*spacingXY/2;

  function pointOfIndex(i){
    const {x,y,z}=toXYZ(i);
    const px=x*spacingXY-half;
    const py=((N-1-y)*spacingXY-half);
    const baseZ=spacingXY*1.35*zScale*(explode?1.55:1.0);
    const pz=((N-1)/2 - z)*baseZ;
    return [px,py,pz];
  }

  function encodeIdToRGB(id){
    const r=(id&255), g=((id>>8)&255), b=((id>>16)&255);
    return [r/255,g/255,b/255];
  }

  const SYMBOL_SCALE = 0.78;
  const SYMBOL_LIFT  = 0.12;

  function syncInstances(){
    for(let i=0;i<SIZE;i++){
      const p = pointOfIndex(i);

      cubeT[i*3+0]=p[0];
      cubeT[i*3+1]=p[1];
      cubeT[i*3+2]=p[2];

      // estetica: FACCE GIOCABILI colorate (shell esterno), interno quasi invisibile
const surf = isSurfaceIndex(i);
const z = toXYZ(i).z;
const layerOpacity = [1.0, 0.78, 0.60, 0.45][z];

// alpha: facce ben visibili, interno ‚Äúfantasma‚Äù
const alpha = (surf ? 0.98 : 0.10) * layerOpacity;

if (surf) {
  const [r,g,b] = surfaceTint(i);   // üé® colore in base alla faccia
  cubeC[i*4+0] = r;
  cubeC[i*4+1] = g;
  cubeC[i*4+2] = b;
} else {
  // interno neutro scuro
  cubeC[i*4+0] = 0.07;
  cubeC[i*4+1] = 0.09;
  cubeC[i*4+2] = 0.12;
}

cubeC[i*4+3] = alpha;

// i cubi restano sempre visibili
cubeV[i] = 1.0;

      const rgb=encodeIdToRGB(i+1);
      cubePick[i*3+0]=rgb[0];
      cubePick[i*3+1]=rgb[1];
      cubePick[i*3+2]=rgb[2];

      const sx=p[0], sy=p[1], sz=p[2]+SYMBOL_LIFT;

      xT[i*3+0]=sx; xT[i*3+1]=sy; xT[i*3+2]=sz;
      xC[i*4+0]=0.29; xC[i*4+1]=0.64; xC[i*4+2]=1.00; xC[i*4+3]=0.98;
      const xOn = board[i]==='X';
      xV[i]=xOn?1.0:0.0;
      xS[i]=xOn?SYMBOL_SCALE:0.0;

      oT[i*3+0]=sx; oT[i*3+1]=sy; oT[i*3+2]=sz;
      oC[i*4+0]=0.27; oC[i*4+1]=0.82; oC[i*4+2]=0.62; oC[i*4+3]=0.98;
      const oOn = board[i]==='O';
      oV[i]=oOn?1.0:0.0;
      oS[i]=oOn?SYMBOL_SCALE:0.0;
    }

    gl.bindBuffer(gl.ARRAY_BUFFER, BUF_CUBE.bIT); gl.bufferSubData(gl.ARRAY_BUFFER,0,cubeT);
    gl.bindBuffer(gl.ARRAY_BUFFER, BUF_CUBE.bIC); gl.bufferSubData(gl.ARRAY_BUFFER,0,cubeC);
    gl.bindBuffer(gl.ARRAY_BUFFER, BUF_CUBE.bIV); gl.bufferSubData(gl.ARRAY_BUFFER,0,cubeV);
    gl.bindBuffer(gl.ARRAY_BUFFER, bPick);         gl.bufferSubData(gl.ARRAY_BUFFER,0,cubePick);
    gl.bindBuffer(gl.ARRAY_BUFFER, bCS);           gl.bufferSubData(gl.ARRAY_BUFFER,0,cubeS);

    gl.bindBuffer(gl.ARRAY_BUFFER, BUF_X.bIT); gl.bufferSubData(gl.ARRAY_BUFFER,0,xT);
    gl.bindBuffer(gl.ARRAY_BUFFER, BUF_X.bIC); gl.bufferSubData(gl.ARRAY_BUFFER,0,xC);
    gl.bindBuffer(gl.ARRAY_BUFFER, BUF_X.bIV); gl.bufferSubData(gl.ARRAY_BUFFER,0,xV);
    gl.bindBuffer(gl.ARRAY_BUFFER, bXS);        gl.bufferSubData(gl.ARRAY_BUFFER,0,xS);

    gl.bindBuffer(gl.ARRAY_BUFFER, BUF_O.bIT); gl.bufferSubData(gl.ARRAY_BUFFER,0,oT);
    gl.bindBuffer(gl.ARRAY_BUFFER, BUF_O.bIC); gl.bufferSubData(gl.ARRAY_BUFFER,0,oC);
    gl.bindBuffer(gl.ARRAY_BUFFER, BUF_O.bIV); gl.bufferSubData(gl.ARRAY_BUFFER,0,oV);
    gl.bindBuffer(gl.ARRAY_BUFFER, bOS);        gl.bufferSubData(gl.ARRAY_BUFFER,0,oS);
  }

  // Preview lines
  function clearPreview(){ previewLines=[]; }

  function linePotential(line, player){
    const opp=(player==='X')?'O':'X';
    let p=0,o=0,e=0;
    for(const c of line){
      if(board[c]===player) p++;
      else if(board[c]===opp) o++;
      else e++;
    }
    if(p>0 && o>0) return 0;
    if(p===3 && e===1) return 1000;
    if(p===2 && e===2) return 80;
    if(p===1 && e===3) return 10;
    if(p===0 && e===4) return 2;
    return 1;
  }

  function setPreviewForCell(i){
    clearPreview();
    if(!teach || gameOver || board[i]) return;
    if(!isSurfaceIndex(i)) return;

    const lines = LINES_THROUGH[i];
    previewLines = lines
      .map(l=>({l, s: linePotential(l, current)}))
      .sort((a,b)=>b.s-a.s)
      .slice(0,10)
      .map(o=>o.l);
  }

  function buildLineVerts(){
    const v=[];
    for(const l of previewLines){
      const a=pointOfIndex(l[0]), b=pointOfIndex(l[3]);
      v.push(...a,...b);
    }
    return new Float32Array(v);
  }

  function setCanvasSize(){
    const dpr=Math.min(2, window.devicePixelRatio||1);
    const w=canvas.clientWidth|0, h=canvas.clientHeight|0;
    const W=(w*dpr)|0, H=(h*dpr)|0;
    if(canvas.width!==W || canvas.height!==H){
      canvas.width=W; canvas.height=H;
      gl.viewport(0,0,W,H);
      ensurePickFbo(W,H);
    }
    return {W,H};
  }

  function getVP(W,H){
    const proj=mat4.persp(45*Math.PI/180, W/H, 0.1, 200);
    const eye=getEye();
    const view=mat4.lookAt(eye, [pan[0],pan[1],pan[2]], [0,1,0]);
    return mat4.mul(proj, view);
  }

  function drawPick(VP,Wm){
    gl.bindFramebuffer(gl.FRAMEBUFFER,pickFbo);
    gl.viewport(0,0,pickW,pickH);
    gl.disable(gl.BLEND); gl.enable(gl.DEPTH_TEST);
    gl.clearColor(0,0,0,1); gl.clear(gl.COLOR_BUFFER_BIT|gl.DEPTH_BUFFER_BIT);

    gl.useProgram(PPICK);
    gl.bindVertexArray(VAO_CUBE.vao);
    gl.uniformMatrix4fv(gl.getUniformLocation(PPICK,'uVP'),false,VP);
    gl.uniformMatrix4fv(gl.getUniformLocation(PPICK,'uW'),false,Wm);
    gl.drawElementsInstanced(gl.TRIANGLES, VAO_CUBE.count, VAO_CUBE.indexType, 0, INST);

    gl.bindVertexArray(null);
    gl.useProgram(null);
    gl.bindFramebuffer(gl.FRAMEBUFFER,null);
  }

  function pickAt(px,py){
    if(!pickFbo || pickW<=0 || pickH<=0) return null;
    const x = clamp(px, 0, pickW - 1);
    const y = clamp(py, 0, pickH - 1);
    const buf = new Uint8Array(4);
    gl.bindFramebuffer(gl.FRAMEBUFFER, pickFbo);
    gl.readPixels(x, y, 1, 1, gl.RGBA, gl.UNSIGNED_BYTE, buf);
    gl.bindFramebuffer(gl.FRAMEBUFFER, null);
    const id = buf[0] + (buf[1] << 8) + (buf[2] << 16);
    if(!id) return null;
    const i = id - 1;

    // Surface battle: si pu√≤ cliccare SOLO sulla superficie
    if(!isSurfaceIndex(i)) return null;
    return i;
  }

  function drawLit(vaoObj, VP, Wm){
    gl.bindVertexArray(vaoObj.vao);
    gl.uniformMatrix4fv(gl.getUniformLocation(PLIT,'uVP'),false,VP);
    gl.uniformMatrix4fv(gl.getUniformLocation(PLIT,'uW'),false,Wm);
    gl.drawElementsInstanced(gl.TRIANGLES, vaoObj.count, vaoObj.indexType, 0, INST);
    gl.bindVertexArray(null);
  }

  function drawMain(VP,Wm){
    gl.viewport(0,0,canvas.width,canvas.height);
    gl.enable(gl.BLEND);
    gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
    gl.clearColor(0,0,0,0);
    gl.clear(gl.COLOR_BUFFER_BIT|gl.DEPTH_BUFFER_BIT);

    gl.useProgram(PLIT);

    gl.enable(gl.DEPTH_TEST);
    gl.depthMask(true);
    drawLit(VAO_CUBE, VP, Wm);

    gl.disable(gl.DEPTH_TEST);
    gl.depthMask(false);
    drawLit(VAO_X, VP, Wm);
    drawLit(VAO_O, VP, Wm);

    gl.depthMask(true);
    gl.enable(gl.DEPTH_TEST);
    gl.useProgram(null);

    const lv=buildLineVerts();
    if(lv.length){
      gl.useProgram(PLINE);
      gl.bindVertexArray(vaoL);
      gl.bindBuffer(gl.ARRAY_BUFFER,vboL);
      gl.bufferData(gl.ARRAY_BUFFER, lv, gl.DYNAMIC_DRAW);
      gl.uniformMatrix4fv(gl.getUniformLocation(PLINE,'uVP'),false,VP);

      if(previewLines.length){
        gl.uniform4f(gl.getUniformLocation(PLINE,'uCol'), 1,1,1, 0.22);
        gl.drawArrays(gl.LINES, 0, previewLines.length*2);
      }
      gl.bindVertexArray(null);
      gl.useProgram(null);
    }
  }

  // Scoring
  function surfaceEmpties(){
    const e=[];
    for(let i=0;i<SIZE;i++){
      if(isSurfaceIndex(i) && !board[i]) e.push(i);
    }
    return e;
  }

  function scoredKey(line){ return line.join(','); }

  function awardNewLinesFor(player){
    // controlla SOLO le linee che passano per l‚Äôultima mossa? (veloce)
    // ma per semplicit√† (4x4x4) possiamo controllare tutte le linee surface
    let gained = 0;

    for(const line of WIN_LINES){
      const key = scoredKey(line);
      if(scoredLines.has(key)) continue;

      const a = board[line[0]];
      if(!a) continue;

      let ok = true;
      for(let k=1;k<line.length;k++){
        if(board[line[k]] !== a){ ok=false; break; }
      }
      if(ok){
        scoredLines.add(key);
        if(a==='X' || a==='O'){
          score[a] += 1;
          gained += 1;
        }
      }
    }

    if(gained){
      updateScores();
      lastScoredLinesText = `+${gained} punto${gained>1?'i':''} per ${player}!`;
      lineInfo.style.display='';
      lineInfo.textContent = lastScoredLinesText;
    }else{
      lineInfo.style.display='none';
      lineInfo.textContent = '';
    }
  }

  function finishIfNoMoves(){
    const e = surfaceEmpties();
    if(e.length) return false;

    gameOver = true;

    let msg = `Fine partita. `;
    if(score.X>score.O) msg += `Vince X (${score.X}‚Äì${score.O}).`;
    else if(score.O>score.X) msg += `Vince O (${score.O}‚Äì${score.X}).`;
    else msg += `Pareggio (${score.X}‚Äì${score.O}).`;

    setStatus(msg);
    updateTurn();
    return true;
  }

  function canPlay(i){
    if(gameOver) return false;
    if(!isSurfaceIndex(i)) return false;
    if(board[i]) return false;
    return true;
  }

  function place(i,who){
    board[i]=who;
    syncInstances();
    clearPreview();
  }

  function play(i){
    if(!canPlay(i)) return;

    place(i,current);

    // scoring: dopo ogni mossa, assegna eventuali linee nuove
    awardNewLinesFor(current);

    // fine partita se finite mosse superficie
    if(finishIfNoMoves()) return;

    current=(current==='X')?'O':'X';
    updateTurn();
    setStatus(`Tocca a ${current}.`);
  }

  // INPUT (FIX iPhone: tap non bloccato, drag rotazione, no scroll pagina)
  let dragging=false, dragMode='rotate', lastX=0,lastY=0;
  let mouseX=0, mouseY=0, mouseMoved=true;

  let tapCandidate=false;
  let tapStartX=0, tapStartY=0;
  const TAP_SLOP=8; // px

  function stopPageScroll(e){
    if(dragging) e.preventDefault();
  }
  canvas.addEventListener('touchmove', stopPageScroll, {passive:false});

  canvas.addEventListener('pointerdown',(e)=>{
    dragging=true;
    tapCandidate = true;
    tapStartX = e.clientX; tapStartY = e.clientY;
    lastX=e.clientX; lastY=e.clientY;

    dragMode = e.shiftKey ? 'pan' : 'rotate';
    canvas.setPointerCapture(e.pointerId);

    // su touch evita selezioni/scroll
    if(e.pointerType === 'touch') e.preventDefault();
  }, {passive:false});

  function endPointer(e){
    // TAP detection: se non si √® mosso, √® un tap ‚Üí piazza
    if(tapCandidate){
      const dx = e.clientX - tapStartX;
      const dy = e.clientY - tapStartY;
      const moved = (dx*dx + dy*dy) > (TAP_SLOP*TAP_SLOP);

      if(!moved){
        const rect=canvas.getBoundingClientRect();
        const dpr=Math.min(2, window.devicePixelRatio||1);
        const px=(e.clientX-rect.left)*dpr;
        const py=(rect.height-(e.clientY-rect.top))*dpr;
        const i=pickAt(px,py);
        if(i!=null){
          // su mobile, tap = anche preview se teach ON (prima prova preview)
          if(teach && !board[i]){
            setPreviewForCell(i);
          }
          play(i);
        }
      }
    }

    dragging=false;
    tapCandidate=false;
    try{ canvas.releasePointerCapture(e.pointerId); }catch(_){}
  }
  canvas.addEventListener('pointerup', endPointer, {passive:false});
  canvas.addEventListener('pointercancel', ()=>{ dragging=false; tapCandidate=false; }, {passive:true});

  canvas.addEventListener('pointermove',(e)=>{
    const rect=canvas.getBoundingClientRect();
    const dpr=Math.min(2, window.devicePixelRatio||1);

    if(dragging){
      const dx=e.clientX-lastX, dy=e.clientY-lastY;
      lastX=e.clientX; lastY=e.clientY;

      if(Math.abs(e.clientX-tapStartX) > TAP_SLOP || Math.abs(e.clientY-tapStartY) > TAP_SLOP){
        tapCandidate=false;
      }

      if(dragMode==='rotate'){
        theta -= dx*0.007;
        phi   -= dy*0.007;
        phi = clamp(phi, 0.15, Math.PI-0.15);
      }else{
        const panSpeed = radius*0.0012;
        pan[0] += -dx*panSpeed;
        pan[1] +=  dy*panSpeed;
      }
      return;
    }

    // hover preview (desktop)
    mouseX=(e.clientX-rect.left)*dpr;
    mouseY=(rect.height-(e.clientY-rect.top))*dpr;
    mouseMoved=true;
  });

  canvas.addEventListener('wheel',(e)=>{
    e.preventDefault();
    const delta=Math.sign(e.deltaY);
    radius *= (delta>0)?1.08:0.92;
    radius = clamp(radius, 6.2, 26);
  },{passive:false});

  // UI
  resetBtn.onclick = ()=>newGame();
  resetScoreBtn.onclick = ()=>{
    score={X:0,O:0};
    updateScores();
    newGame(true);
  };

  explodeSwitch.onclick = ()=>{
    explode = toggleSwitch(explodeSwitch);
    explodeBadge.textContent = explode?'ON':'OFF';
    syncInstances();
  };

  zDepth.oninput = ()=>{
    zScale = Number(zDepth.value);
    syncInstances();
  };

  teachSwitch.onclick = ()=>{
    teach = toggleSwitch(teachSwitch);
    teachBadge.textContent = teach?'ON':'OFF';
    if(!teach) clearPreview();
  };

  function newGame(resetLinesAlso=false){
    board=Array(SIZE).fill(null);
    current='X';
    gameOver=false;
    hoveredIndex=null;
    previewLines=[];
    lineInfo.style.display='none';
    lineInfo.textContent='';

    if(resetLinesAlso){
      scoredLines.clear();
      score={X:0,O:0};
      updateScores();
    }else{
      // nuova partita: reset linee contate SOLO per partita
      scoredLines.clear();
      score={X:0,O:0};
      updateScores();
    }

    syncInstances();
    setStatus('Tocca a X.');
    updateTurn();
  }

  // LOOP
  function tick(){
    const {W,H}=setCanvasSize();
    fitCameraToView(W,H);

    const VP=getVP(W,H);
    const Wm=getWorld();

    drawPick(VP,Wm);

    // hover preview desktop
    if(mouseMoved){
      hoveredIndex = pickAt(mouseX, mouseY);
      if(teach && hoveredIndex!=null && canPlay(hoveredIndex)) setPreviewForCell(hoveredIndex);
      else clearPreview();
      mouseMoved=false;
    }

    drawMain(VP,Wm);
    requestAnimationFrame(tick);
  }

  // INIT
  updateScores();
  toggleSwitch(explodeSwitch,false); explodeBadge.textContent='OFF';
  toggleSwitch(teachSwitch,true); teachBadge.textContent='ON';

  syncInstances();
  newGame();
  tick();
})();
</script>
</body>
</html>
